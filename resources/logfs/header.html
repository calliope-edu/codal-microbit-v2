<html>
  <head>
    <meta charset="utf-8" />
    <style>
      /* Horizontal stack */
      .bb {
        display: flex;
      }
      .bb > * + * {
        margin-left: 10px;
      }
      body {
        font-family: sans-serif;
        margin: 1em;
      }
      table {
        border-collapse: collapse;
        margin-top: 1em;
        text-align: right;
      }
      tr:first-child {
        font-weight: bold;
      }
      td {
        border: 1px solid #ddd;
        padding: 8px;
        min-width: 8ch;
      }
      iframe {
        display: none;
      }
    </style>
    <link rel="stylesheet" href="https://microbit.org/dl/2/dl.css" />
    <script>
      // These help significantly to save bytes.
      let w = window;
      let d = document;
      let l = w.location;
      let n = null;
      // CSV
      let v = "";
      let a = msg => alert.bind(n, msg);
      // By using obj[c] syntax, we can invoke this whilst saving bytes.
      let c = "createElement";
      let m = " your micro:bit";
      // Allow external JS to override these actions if we managed to load it.
      // This script block is first so external JS can override individual functions.
      w.dl = {
        download() {
          let a = d[c]("a"); // document.createElement
          a.download = "microbit.csv";
          a.href = URL.createObjectURL(new Blob([v], { type: "text/plain" }));
          a.click();
          a.remove();
        },
        copy() {
          navigator.clipboard.writeText(v.replace(/\,/g, "\t"));
        },
        update: a("Unplug" + m + ", then plug it back in and wait"),
        clear: a("The log is cleared when you reflash" + m),
        load() {
          // Find the CSV text in the file system
          let p = d.querySelector("#w");
          let raw = d.documentElement.outerHTML.split("FS_START")[2];
          let append = tagName => p.appendChild(d[c](tagName)); // document.createElement
          // See MicroBitLog.h/cpp for the format.
          if (/^UBIT_LOG_FS_V_002/.test(raw)) {
            let parseInteger = parseInt;

            let dataStart = parseInteger(raw.substr(29, 10), 16) - 2048;
            let dataSize = 0;
            while (raw.charCodeAt(dataStart + dataSize) != 0xfffd) {
              dataSize++;
            }
            if (!dataSize) {
              append("p").innerText = "Log is empty. Logged data will appear here.";
            }
            v = raw.substr(dataStart, dataSize);

            // Hash the content and reload if it changes using an iframe to check for a different hash
            let hash = 0;
            for (let i = 0; i < raw.length; ++i) {
              hash = 31 * hash + raw.charCodeAt(i);
              hash |= 0;
            }
            let other = l.href.split("?")[1];
            if (other !== undefined) {
              // We're the iframe. Check the hash from the URL and request the parent reload if it differs.
              if (other != hash) {
                parent.postMessage("diff", "*");
              }
            } else {
              // We're the parent so add content.

              // Full log indicator
              // We also plan to add a "Log 65% full" indicator here in online mode.
              let logEnd = parseInteger(raw.substr(18, 10), 16);
              if (raw.substr(logEnd - 2048 + 1, 3) === "FUL") {
                append("p").innerHTML = "Log is full. <a href='https://microbit.org/dl/full'>Find out more.</a>";
              }

              let table = append("table");
              v.split("\n").forEach(r => {
                let tr = table.insertRow();
                r && r.split(",").forEach(c => tr.insertCell().innerText = c);
              });

              // Wait for reload messages and continually reload our iframe.
              w.onmessage = e => {
                if (e.data == "diff") {
                  // MAYBE: Skip this if the tab is not visible.
                  l.reload();
                }
              };
              // We assume that 5s is long enough to load a file from disk.
              // We can't afford the bytes to have onload/onerror handlers.
              let iframe;
              setInterval(() => {
                iframe && iframe.remove();
                iframe = append("iframe");
                iframe.src = l.href + "?" + hash;
              }, 5_000);
            }
          }
          return raw;
        },
      };
    </script>
    <script src="https://microbit.org/dl/2/dl.js"></script>
    <title>micro:bit data log</title>
  </head>
  <body onload="dl.load()">
    <div id="w">
      <h1>micro:bit data log</h1>
      <div class="bb">
        <button onclick="dl.download()">Download</button>
        <button onclick="dl.copy()">Copy</button>
        <button onclick="dl.update()">Update data&mldr;</button>
        <button onclick="dl.clear()">Clear log&mldr;</button>
      </div>
      <p id="v">Offline: no visual preview</p>
    </div>
  </body>
</html>
